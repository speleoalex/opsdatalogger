<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV to Chart</title><!-- papaparse.min.js chart.js  -->

    <script src="loggerviewer.js">
        
    </script>
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
        }

        button {
            background-color: limegreen;
            color: black;
            border: none;
            padding: 5px 15px;
            cursor: pointer;
            margin: 3px;
            border-radius: 6px;
        }

        #loggerviewer {
            background-color: orange;
            float: right;
        }

        button:disabled {
            background-color: grey;
        }
    </style>
</head>

<body>
    <nav>
        <input style="display:none" id="logfile" type="file" id="csvFileInput" accept=".csv,.txt"
            onchange="handleFiles(this.files)" />
        <button id="loggerviewer" onclick="window.location='loggermanager.htm'">Logger manager</button>
        <button onclick="document.getElementById('logfile').click();">Open CSV file</button>
        <div style="display:none" id="MQ2Div">
            <fieldset>
            <legend>Calibration</legend>
            Start row:<input value="1" min="1" placeholder="start" id="startfrom" onchange="updateChartWithZerogas();"
                type="number" min="0" max="1023" value="">
            ZeroGas:<input placeholder="zero gas adc" id="zerogasInput" onchange="updateChartWithZerogas();" type="number"
                min="0" max="1023" value=""><button onclick="ZeroGasAuto();">Auto</button>
            <label><input type="checkbox" id="heatingCompensation" onchange="toggleHeatingParams(); updateChartWithZerogas();"> Heating compensation</label>
            <br>
            <span id="heatingParams" style="display:none;">
                Heating time (min): <input type="number" id="heatingTime" value="120" min="1" max="900" onchange="updateChartWithZerogas();">
                Initial ADC value: <input type="number" id="initialADC" value="" placeholder="Auto" onchange="updateChartWithZerogas();"><button onclick="HeatingAuto();">Auto</button>
                Curvature factor: <input type="number" id="curveFactor" value="9" min="1" max="20" step="0.1" onchange="updateChartWithZerogas();">
            </span>
            </fieldset>
            <div style="text-align: right;">
            <button onclick="exportCSV();">Export CSV</button>
            </div>
        </div>

    </nav>
    <canvas id="myChart"></canvas>
    <script>
        var DatasetsCSV = [];
        var DatasetsClean = [];

        var labels = [];
        var datasetVisibilityState = {};
        // Sensor characteristics for calibration  -------->
        var RO_CLEAN_AIR_FACTOR = 9.83;
        var RL_VALUE = 5.0;
        var LPGCurve = [2.3, 0.21, -0.47];
        function IsMQ2Chart() {
            try {
                if (DatasetsCSV[0].label == "gas adc" && (DatasetsCSV[1].label.trim() == "LPG PPM" || DatasetsCSV[1].label.trim() == "LPG PPB")) {
                    return true;
                }

            } catch (e) { }
            return false;
        }
        function ZeroGasAuto() {
            var MinRaw = 1023;
            var consec = 0;
            var prev;
            for (var i in DatasetsCSV[0].data) {
                if (i > 0) {
                    var CurRawValue = parseFloat(DatasetsCSV[0].data[i]);
                    if (CurRawValue > 0 && MinRaw > DatasetsCSV[0].data[i]) {
                        if (prev == CurRawValue) {
                            MinRaw = CurRawValue;
                        }
                    }
                    prev = CurRawValue;
                }
            }
            MinRaw = Math.round(MinRaw);
            document.getElementById("zerogasInput").value = MinRaw;
            document.getElementById("zerogasInput").onchange();

        }

        var RO_CLEAN_AIR_FACTOR = 9.83;
        var RL_VALUE = 5.0;
        var LPGCurve = [2.3, 0.21, -0.47];


        function MQ2_RawToPPM(rawValue, zeroGasValue) {
            // If the zero calibration value is less than or equal to 0, set it to 1 to avoid division by zero
            rawValue = parseFloat(rawValue);
            zeroGasValue = parseFloat(zeroGasValue);
            if (zeroGasValue < 1) {
                zeroGasValue = 1;
            }
            // If the zero calibration value is greater than or equal to the raw value, return 0 (no gas)
            if (rawValue < zeroGasValue) {
                return 0;
            }
            // Calculate the resistance of the sensor at zero gas concentration
            ResZero = MQResistanceCalculation(zeroGasValue) / RO_CLEAN_AIR_FACTOR;
            // Calculate the current sensor resistance
            ResCurrent = MQResistanceCalculation(rawValue);
            console.log("ResZero=" + ResZero);
            // Calculate the gas concentration percentage
            PPM = MQ2_PPM_gas(ResCurrent, ResZero, LPGCurve);
            // Fix Marco Corvi
            return PPM;
        }

        // Function for sensor heating compensation
        function applyHeatingCompensation(currentADC, timeMinutes, heatingTimeMinutes, initialADC, zeroGasADC, curveFactor) {
            if (!heatingTimeMinutes || heatingTimeMinutes <= 0 || timeMinutes < 0 || !initialADC) {
                return MQ2_RawToPPM(currentADC, zeroGasADC);
            }
            
            // If the time is greater than the heating time, use the normal value
            if (timeMinutes >= heatingTimeMinutes) {
                return MQ2_RawToPPM(currentADC, zeroGasADC);
            }
            
            // Calculate the correction with a configurable curvature factor
            // Where t is normalized between 0 and 1 (0 = start, 1 = end of heating)
            let normalizedTime = timeMinutes / heatingTimeMinutes;
            
            // Use the curvature factor to make the curve steeper or less steep
            // curveFactor = 1: linear, curveFactor = 2: parabolic, curveFactor > 2: steeper
            let curvatureExponent = curveFactor || 9;
            
            // Calculate the ADC difference due to heating
            // At the beginning (t=0), the difference is maximum (initialADC - zeroGasADC)
            // At the end (t=1), the difference is zero
            let adcHeatingError = (initialADC - zeroGasADC) * Math.pow(1 - normalizedTime, curvatureExponent);
            
            // Subtract the heating error from the current ADC value
            let compensatedADC = currentADC - adcHeatingError;
            compensatedADC = Math.max(compensatedADC, zeroGasADC);
            // Convert the compensated ADC value to PPM
            return MQ2_RawToPPM(compensatedADC, zeroGasADC);
        }

        // Checkbox management to show/hide parameters
        function toggleHeatingParams() {
            const checkbox = document.getElementById('heatingCompensation');
            const params = document.getElementById('heatingParams');
            
            if (checkbox.checked) {
                params.style.display = 'inline';
                // Auto-detect the initial ADC value if not set
                if (!document.getElementById('initialADC').value && DatasetsClean.length > 0 && DatasetsClean[0].data.length > 0) {
                    document.getElementById('initialADC').value = Math.round(DatasetsClean[0].data[0]);
                }
            } else {
                params.style.display = 'none';
            }
        }

        // Auto function for automatic detection of initial ADC value
        function HeatingAuto() {
            var startfrom = parseInt(document.getElementById("startfrom").value) - 1;
            
            if (DatasetsCSV.length > 0 && DatasetsCSV[0].data.length > startfrom) {
                // Takes the first valid ADC value after the starting position
                var initialADC = DatasetsCSV[0].data[startfrom];
                document.getElementById('initialADC').value = Math.round(initialADC);
                
                // Update the chart with the new value
                updateChartWithZerogas();
                
                console.log("Auto heating compensation: Initial ADC set to " + Math.round(initialADC));
            } else {
                alert("No data available. Please load a CSV file first.");
            }
        }
        // Function to calculate the percentage of gas concentration
        function MQ2_PPM_gas(resCurrent, resZero) {
            // Calculate the ratio of current resistance to zero gas resistance
            rs_ro_ratio = resCurrent / resZero;
            // Calculate and return the gas concentration using the calibration curve
            var ret = Math.pow(10, ((Math.log10(rs_ro_ratio) - LPGCurve[1]) / LPGCurve[2] + LPGCurve[0]));
            if (isNaN(ret)) {
                ret = 0;
            }
            return ret;
        }

        /****************** MQResistanceCalculation ****************************************
        Input:   raw_adc - raw value read from adc, which represents the voltage
        Output:  the calculated sensor resistance
        Remarks: The sensor and the load resistor forms a voltage divider. Given the voltage
                across the load resistor and its resistance, the resistance of the sensor
                could be derived.
        ************************************************************************************/
        function MQResistanceCalculation(raw_adc) {
            if (isNaN(raw_adc) || raw_adc < 1) {
                raw_adc = 1;
            }
            if (raw_adc > 1023) {
                raw_adc = 1023;
            }
            // Calculate and return the sensor resistance
            //console.log(`${RL_VALUE} * (1023.0 - ${raw_adc}) / ${raw_adc}`);
            return ((RL_VALUE * (1023.0 - raw_adc) / raw_adc));
        }

        function updateChartWithZerogas() {
            var rawZeroGas = document.getElementById("zerogasInput").value;
            var startfrom = parseInt(document.getElementById("startfrom").value) - 1;
            
            // Parameters for heating compensation
            var heatingEnabled = document.getElementById("heatingCompensation").checked;
            var heatingTime = parseFloat(document.getElementById("heatingTime").value) || 120;
            var initialADC = parseFloat(document.getElementById("initialADC").value);
            var curveFactor = parseFloat(document.getElementById("curveFactor").value) || 9;
            
            console.log("data 0");
            var i;
            for (i in DatasetsCSV[0].data) {
                if (i >= startfrom) {
                    DatasetsClean[1].data[i] = DatasetsCSV[1].data[i];
                    DatasetsClean[0].data[i] = DatasetsCSV[0].data[i];
                    
                    // Apply heating compensation if enabled
                    if (heatingEnabled) {
                        // Calculate the elapsed time in minutes from the start of the data
                        var timeFromStart = (i - startfrom) * 0.5; // Assuming 30 seconds between readings
                        
                        // If initialADC is not set, use the first ADC value
                        if (!initialADC && i == startfrom) {
                            initialADC = DatasetsClean[0].data[i];
                            document.getElementById("initialADC").value = Math.round(initialADC);
                        }
                        
                        DatasetsClean[1].data[i] = applyHeatingCompensation(DatasetsClean[0].data[i], timeFromStart, heatingTime, initialADC, rawZeroGas, curveFactor);
                    } else {
                        // Calculate normal PPM without compensation
                        DatasetsClean[1].data[i] = MQ2_RawToPPM(DatasetsClean[0].data[i], rawZeroGas);
                    }
                }
                else {
                    DatasetsClean[1].data[i] = 0;
                    DatasetsClean[0].data[i] = 0;
                }
            }
            displayChart(labels, DatasetsClean);
        }
        // Sensor characteristics for calibration  --------<
        function saveCSV(csvContent) {
            fileName = "export";
            // Create column headers based on dataset labels
            csvContent = 'data:text/csv;charset=utf-8,' + csvContent;
            // Create the download link
            var encodedUri = encodeURI(csvContent);
            var link = document.createElement('a');
            link.setAttribute('href', encodedUri);
            link.setAttribute('download', fileName + '.csv');
            document.body.appendChild(link); // Needed for Firefox
            // Download the file
            link.click();
            document.body.removeChild(link); // Cleanup            
        }

        function exportCSV() {
            var csvContent = "";
            var csvContentArray = [];
            var csvData = [];
            console.log(labels);
            console.log(DatasetsClean);
            for (var i in DatasetsClean) {
                csvContentArray[i] = DatasetsClean[i].label;
            }
            csvContent += "\"date Y-m-d m:s\";" + csvContentArray.join(";") + "\r\n";
            console.log(csvContent);
            for (var i_row in labels) {
                csvData[i_row] = [];
                csvData[i_row][0] = labels[i_row];
            }
            for (var i_col in DatasetsClean) {
                for (var i_row in DatasetsClean[i_col].data) { //n
                    csvData[i_row][parseInt(i_col) + 1] = DatasetsClean[i_col].data[i_row];
                }
            }
            console.log("csvData:");
            console.log(csvData);
            for (var i_row in csvData) {
                csvContent += csvData[i_row].join(";") + "\r\n";
            }
            console.log(csvContent);
            saveCSV(csvContent);
        }

        function hasDelimiterInFirstLine(str, delimiter) {
            // Find the index of the first occurrence of a carriage return
            const firstNewLineIndex = str.indexOf('\n');

            // If there is no newline, it checks the entire string, 
            // otherwise it only checks up to the first newline
            const firstLine = firstNewLineIndex === -1 ? str : str.substring(0, firstNewLineIndex);

            // Checks whether the tab character is present in the first line
            return firstLine.includes(delimiter);
        }

        function saveToSessionStorage(key, value) {
            try {
                sessionStorage.setItem(key, value);
                console.log('Data saved successfully');
            } catch (e) {
                console.error('Error saving data', e);
            }
        }
        function readFromSessionStorage(key) {
            try {
                const value = sessionStorage.getItem(key);
                if (value === null) {
                    console.log('No data found for key:', key);
                    return null;
                } else {
                    console.log('Data found:', value);
                    return value;
                }
            } catch (e) {
                console.error('Error reading data', e);
                return null;
            }
        }

        var myChart;
        var csvdata = readFromSessionStorage("csv");
        if (csvdata != null && csvdata != "") {
            parseCSVData(csvdata);
        }
        function handleFiles(files) {
            document.getElementById("startfrom").value = 1;
            saveToSessionStorage("csv", null);
            labels = [];
            DatasetsCSV = [];
            DatasetsClean = [];

            if (window.FileReader) {
                let reader = new FileReader();
                reader.onload = function (event) {
                    let csvdata = event.target.result;
                    parseCSVData(csvdata);
                };
                reader.readAsText(files[0]);
            }
        }


        var indexColor = -1;


        function parseCSVData(csvdata) {
            var delimiter = ";";
            if (hasDelimiterInFirstLine(csvdata, "\t")) {
                delimiter = "\t";
            }
            else {
                if (hasDelimiterInFirstLine(csvdata, ",")) {
                    delimiter = ",";
                }
            }
            indexColor = -1;
            var rows = csvdata.split("\n");
            var results = [];
            rows.forEach(function (row) {
                var rowItems = [];
                var currentItem = '';
                var inQuotes = false;
                row = row.replace("\r", "");
                if (row !== "") {
                    for (var i = 0; i < row.length; i++) {
                        var currentChar = row[i];

                        if (currentChar === '"' && row[i - 1] !== '\\') {
                            inQuotes = !inQuotes;
                            continue;
                        }

                        if (currentChar === delimiter && !inQuotes) {
                            rowItems.push(currentItem);
                            currentItem = '';
                        } else {
                            currentItem += currentChar;
                        }
                    }

                    rowItems.push(currentItem); // Add the last element
                    results.push(rowItems);
                }
            });
            console.log("Parsed results:", results);
            var startData = 2;
            if (results[0][0] != "count") {
                startData = 1;
            }
            var indexData = startData - 1;
            var i = 0;
            results.slice(indexData).forEach(row => {
                if (i > 0) {
                    labels.push(row[indexData]); // X-axis
                }
                i++;
            });
            for (let i = startData; i < results[0].length; i++) {
                let datasetDataCSV = [];
                let datasetDataCLEAN = [];

                var i_row = 0;
                results.slice(indexData).forEach(row => {
                    if (i_row > 0) {
                        datasetDataCSV.push(row[i]);
                        datasetDataCLEAN.push(row[i]);

                    }
                    i_row++;
                });
                DatasetsCSV.push({
                    label: results[0][i],
                    data: datasetDataCSV,
                    borderColor: indexRGB(),
                    borderWidth: 1,
                    fill: false
                });
                DatasetsClean.push({
                    label: results[0][i],
                    data: datasetDataCLEAN,
                    borderColor: indexRGB(),
                    borderWidth: 1,
                    fill: false
                });
            }
            displayChart(labels, DatasetsClean);
        }

        function randomRGB() {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
            return `rgb(${r}, ${g}, ${b})`;
        }

        function indexRGB() {
            indexColor++;
            var rgb = [];
            rgb[0] = `orange`;
            rgb[1] = `magenta`;
            rgb[2] = `blue`;
            rgb[3] = `red`;
            rgb[4] = `#da00da`;
            rgb[5] = `#00dada`;

            if (indexColor >= rgb.length) {
                return randomRGB();
            }
            return rgb[indexColor];
        }

        function displayChart(labels, datasets) {
            // Preserve dataset visibility state before destroying the chart
            if (window.myChart instanceof Chart) {
                // Save the visibility state of each dataset by label
                for (let i = 0; i < window.myChart.data.datasets.length; i++) {
                    const dataset = window.myChart.data.datasets[i];
                    const meta = window.myChart.getDatasetMeta(i);
                    datasetVisibilityState[dataset.label] = !meta.hidden;
                }
                window.myChart.destroy();
            }
            
            // Apply saved visibility state to new datasets and configure y-axis assignment for MQ2 charts
            for (let i = 0; i < datasets.length; i++) {
                const dataset = datasets[i];
                if (datasetVisibilityState.hasOwnProperty(dataset.label)) {
                    // If dataset was previously hidden, mark it as hidden
                    dataset.hidden = !datasetVisibilityState[dataset.label];
                }
                
                // Configure y-axis assignment for MQ2 charts
                if (IsMQ2Chart()) {
                    if (dataset.label === "gas adc") {
                        dataset.yAxisID = 'y'; // Left y-axis for Gas ADC
                    } else if (dataset.label.trim() === "LPG PPM" || dataset.label.trim() === "LPG PPB") {
                        dataset.yAxisID = 'y1'; // Right y-axis for LPG PPM/PPB
                    }
                }
            }
            
            if (datasets.length > 0 && IsMQ2Chart()) {
                document.getElementById("MQ2Div").style.display = "block";
            }
            else {
                document.getElementById("MQ2Div").style.display = "none";

            }
            
            // Configure chart options based on chart type
            let chartOptions;
            if (IsMQ2Chart()) {
                // Dual y-axis configuration for MQ2 charts
                chartOptions = {
                    animation: false,
                    scales: {
                        y: {
                            type: 'linear',
                            position: 'left',
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Gas ADC'
                            }
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'LPG PPM'
                            },
                            grid: {
                                drawOnChartArea: false, // Only want the grid lines for one axis to show up
                            }
                        }
                    }
                };
            } else {
                // Single y-axis configuration for other charts
                chartOptions = {
                    animation: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            min: 0
                        }
                    }
                };
            }
            
            let ctx = document.getElementById('myChart').getContext('2d');
            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: chartOptions
            });
        }
    </script>

</body>

</html>